# -*- coding: utf-8 -*-
"""simple_code.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jScMCYg4ZzpgfUL6wuC3zdspQBc9zwM3
"""

# ================================================================
# FULL DNA â†’ PROTEIN TRANSLATION + DATA SCIENCE IMPORTS
# ================================================================
# This script combines:
# - Enhanced DNA translation utilities
# - Error handling and validation
# - Reverse complement computation
# - ORF-based translation
# - Raw frame-by-frame translation
# - Comprehensive imports for data analysis and plotting
#
# Suitable for educational, research, and computational work.
# ================================================================


# ================================================================
# EXPECTED IMPORTS (as requested)
# ================================================================
import pandas as pd
from pandas import read_csv
from pandas import DataFrame

import seaborn as sns
import seaborn as sb
from seaborn import clustermap, scatterplot, heatmap, kdeplot
from seaborn import color_palette as palette

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure, subplots, axvline, axhline, show

import numpy as np
import csv


# ================================================================
# FULL CODON TABLE (All 64 codons)
# ================================================================
codon_table = {
    "TTT": "F", "TTC": "F",
    "TTA": "L", "TTG": "L", "CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
    "ATT": "I", "ATC": "I", "ATA": "I",
    "ATG": "M",  # Start codon
    "GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
    "TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
    "AGT": "S", "AGC": "S",
    "CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
    "ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
    "GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
    "TAT": "Y", "TAC": "Y",
    "CAT": "H", "CAC": "H",
    "CAA": "Q", "CAG": "Q",
    "AAT": "N", "AAC": "N",
    "AAA": "K", "AAG": "K",
    "GAT": "D", "GAC": "D",
    "GAA": "E", "GAG": "E",
    "TGT": "C", "TGC": "C",
    "TGG": "W",
    "CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
    "AGA": "R", "AGG": "R",
    "GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G",
    "TAA": "*", "TAG": "*", "TGA": "*"  # Stop codons
}


# ================================================================
# DNA VALIDATION + SUPPORT FUNCTIONS
# ================================================================
def validate_dna(seq):
    """
    Validate that a sequence contains only A, T, C, and G.
    Raises a ValueError immediately if non-DNA bases are found.
    """
    seq = seq.upper().replace(" ", "")

    for i, base in enumerate(seq):
        if base not in "ATCG":
            raise ValueError(
                f"Invalid base '{base}' at position {i}. "
                "DNA sequences must contain only A, T, C, G."
            )
    return seq


# For reverse complement mapping
complement_map = str.maketrans("ATCG", "TAGC")


def reverse_complement(seq):
    """
    Compute the reverse complement of a validated DNA sequence.
    """
    seq = validate_dna(seq)
    return seq.translate(complement_map)[::-1]


# ================================================================
# TRANSLATION FUNCTIONS
# ================================================================
def translate_raw(dna_seq):
    """
    Raw translation from position 0.
    Incomplete or unknown codons become 'X'.

    NOTE:
    - No attempt is made to model biological start sites.
    - This is a simple codon-by-codon conversion.
    """
    dna_seq = validate_dna(dna_seq)
    protein = ""

    for i in range(0, len(dna_seq), 3):
        codon = dna_seq[i:i+3]

        if len(codon) < 3:
            protein += "X"  # incomplete codon
            continue

        protein += codon_table.get(codon, "X")  # unknown codon safeguard

    return protein


def translate_orf(dna_seq):
    """
    Translate only the first ORF (Open Reading Frame) in a DNA sequence.

    ORF rules used here:
    - Translation begins at first ATG
    - Stops at the first stop codon (TAA, TAG, or TGA)
    - Does not consider splicing, polycistronic mRNA, UTRs, or context-based initiation.

    This function is for educational / computational illustration.
    """

    dna_seq = validate_dna(dna_seq)

    # Locate the first ATG
    start = dna_seq.find("ATG")
    if start == -1:
        return ""  # No ORF found

    protein = ""

    for i in range(start, len(dna_seq), 3):
        codon = dna_seq[i:i+3]

        if len(codon) < 3:
            break  # incomplete final codon

        aa = codon_table.get(codon, "X")

        if aa == "*":
            break  # stop codon reached

        protein += aa

    return protein


def translate_all_frames(dna_seq):
    """
    Translate all 3 forward reading frames.
    Useful for ORF exploration and visualization.
    """
    dna_seq = validate_dna(dna_seq)

    return {
        f"Frame {frame}": translate_raw(dna_seq[frame:])
        for frame in range(3)
    }


# ================================================================
# DEMO EXECUTION (Safe to remove if using as a module)
# ================================================================
if __name__ == "__main__":
    dna_example = "ATGTTTGGTGGA"

    print("Original DNA:", dna_example)
    print("Reverse Complement:", reverse_complement(dna_example), "\n")

    print("Raw Translation:", translate_raw(dna_example))
    print("ORF Translation:", translate_orf(dna_example))
    print("Reverse ORF Translation:", translate_orf(reverse_complement(dna_example)))

    print("\nAll Frames:")
    frames = translate_all_frames(dna_example)
    for frame, protein in frames.items():
        print(f"{frame}: {protein}")