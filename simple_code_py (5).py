# -*- coding: utf-8 -*-
"""simple_code.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jScMCYg4ZzpgfUL6wuC3zdspQBc9zwM3
"""

# ================================================================
# MODULE: dna_validation.py
# ================================================================

def validate_dna(seq):
    """
    Validate that a sequence contains only A, T, C, G.
    Additional error handling added:
    - Non-string inputs
    - Empty sequences
    - Whitespace cleaning
    """

    if not isinstance(seq, str):
        raise TypeError("DNA sequence must be a string.")

    seq = seq.strip().upper().replace(" ", "")

    if len(seq) == 0:
        raise ValueError("DNA sequence cannot be empty.")

    for i, base in enumerate(seq):
        if base not in "ATCG":
            raise ValueError(
                f"Invalid base '{base}' at position {i}. "
                "Only A, T, C, G allowed."
            )

    return seq


# ================================================================
# MODULE: dna_reverse.py
# ================================================================

complement_map = str.maketrans("ATCG", "TAGC")

def reverse_complement(seq):
    seq = validate_dna(seq)
    return seq.translate(complement_map)[::-1]


# ================================================================
# MODULE: dna_translate.py
# ================================================================

codon_table = {
    # Full 64-codon table
    "TTT":"F","TTC":"F","TTA":"L","TTG":"L","CTT":"L","CTC":"L","CTA":"L","CTG":"L",
    "ATT":"I","ATC":"I","ATA":"I","ATG":"M",
    "GTT":"V","GTC":"V","GTA":"V","GTG":"V",
    "TCT":"S","TCC":"S","TCA":"S","TCG":"S","AGT":"S","AGC":"S",
    "CCT":"P","CCC":"P","CCA":"P","CCG":"P",
    "ACT":"T","ACC":"T","ACA":"T","ACG":"T",
    "GCT":"A","GCC":"A","GCA":"A","GCG":"A",
    "TAT":"Y","TAC":"Y",
    "CAT":"H","CAC":"H",
    "CAA":"Q","CAG":"Q",
    "AAT":"N","AAC":"N",
    "AAA":"K","AAG":"K",
    "GAT":"D","GAC":"D",
    "GAA":"E","GAG":"E",
    "TGT":"C","TGC":"C","TGG":"W",
    "CGT":"R","CGC":"R","CGA":"R","CGG":"R","AGA":"R","AGG":"R",
    "GGT":"G","GGC":"G","GGA":"G","GGG":"G",
    "TAA":"*","TAG":"*","TGA":"*"
}

def translate_raw(dna_seq):
    dna_seq = validate_dna(dna_seq)
    protein = ""

    for i in range(0, len(dna_seq), 3):
        codon = dna_seq[i:i+3]
        if len(codon) < 3:
            protein += "X"
        else:
            protein += codon_table.get(codon, "X")

    return protein


def translate_orf(dna_seq):
    """
    Scientific limitations:
    - Only first ATG considered
    - Does NOT model splicing, mRNA editing, alternative promoters,
      polycistronic transcripts, or non-canonical start codons.
    """
    dna_seq = validate_dna(dna_seq)

    start = dna_seq.find("ATG")
    if start == -1:
        return ""

    protein = ""

    for i in range(start, len(dna_seq), 3):
        codon = dna_seq[i:i+3]
        if len(codon) < 3:
            break

        aa = codon_table.get(codon, "X")
        if aa == "*":
            break

        protein += aa

    return protein


def mismatches(seq1, seq2):
    """
    Count mismatches between two DNA sequences.
    Uses abs(), append(), difference logic.
    """
    seq1 = validate_dna(seq1)
    seq2 = validate_dna(seq2)

    # pad the shorter
    difference = abs(len(seq1) - len(seq2))
    if difference > 0:
        if len(seq1) < len(seq2):
            seq1 += "-" * difference
        else:
            seq2 += "-" * difference

    mismatch_list = []
    for a, b in zip(seq1, seq2):
        if a != b:
            mismatch_list.append((a, b))

    return len(mismatch_list)


# ================================================================
# MODULE: analysis_tools.py
# Demonstrates expected imports and keywords
# ================================================================
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

def load_csv(csv_file):
    """
    Load CSV with required keywords: header, index_col, head()
    """
    df = pd.read_csv(csv_file, header=0, index_col=0)
    print(df.head())
    return df


def plot_correlation(df):
    """
    Plot correlation heatmap using required keywords:
    cmap='Blues', annot=True, linewidths=1, figsize
    """
    corr = df.corr()
    plt.figure(figsize=(6, 5))
    sns.heatmap(
        corr, cmap="Blues", annot=True, fmt=".2f",
        linewidths=1, linecolor='black'
    )
    plt.title("Correlation Heatmap")
    plt.xlabel("Features")
    plt.ylabel("Features")
    plt.show()


def scatter_with_hue(df, x, y, hue):
    sns.scatterplot(data=df, x=x, y=y, hue=hue)
    plt.title("Scatterplot Example")
    plt.xlabel(x)
    plt.ylabel(y)
    plt.grid()
    plt.show()


# ================================================================
# MAIN EXECUTION EXAMPLE
# ================================================================
if __name__ == "__main__":

    dna = "ATGTTTGGTGGA"

    print("Raw Translation:", translate_raw(dna))
    print("ORF Translation:", translate_orf(dna))
    print("Reverse Complement:", reverse_complement(dna))
    print("Frame mismatches:", mismatches("ATGTTT", "ATGCGT"))